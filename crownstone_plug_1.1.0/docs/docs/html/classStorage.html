<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Bluenet: Storage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bluenet
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
   <div id="projectbrief">Bluenet, the firmware for the Crownstone power outlet</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classStorage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Storage Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to store items persistently in FLASH.  
 <a href="classStorage.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cs__Storage_8h_source.html">cs_Storage.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Storage:</div>
<div class="dyncontent">
<div class="center"><img src="classStorage__inherit__graph.png" border="0" usemap="#Storage_inherit__map" alt="Inheritance graph"/></div>
<map name="Storage_inherit__map" id="Storage_inherit__map">
<area shape="rect" id="node2" href="classEventListener.html" title="Event listener. " alt="" coords="5,5,108,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Storage:</div>
<div class="dyncontent">
<div class="center"><img src="classStorage__coll__graph.png" border="0" usemap="#Storage_coll__map" alt="Collaboration graph"/></div>
<map name="Storage_coll__map" id="Storage_coll__map">
<area shape="rect" id="node2" href="classEventListener.html" title="Event listener. " alt="" coords="5,5,108,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a98b01eb20a64a4bf4127685147f7f6f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98b01eb20a64a4bf4127685147f7f6f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="separator:a98b01eb20a64a4bf4127685147f7f6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f04f8d88cc9064b8ddfb8b84e15a5a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f04f8d88cc9064b8ddfb8b84e15a5a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInitialized</b> ()</td></tr>
<tr class="separator:a8f04f8d88cc9064b8ddfb8b84e15a5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e2d45dbf3457ee4f5acbb268be0771"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#aa5e2d45dbf3457ee4f5acbb268be0771">getHandle</a> (ps_storage_id storageID, pstorage_handle_t &amp;handle)</td></tr>
<tr class="memdesc:aa5e2d45dbf3457ee4f5acbb268be0771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the handle to the persistent memory for the given storage ID.  <a href="#aa5e2d45dbf3457ee4f5acbb268be0771">More...</a><br /></td></tr>
<tr class="separator:aa5e2d45dbf3457ee4f5acbb268be0771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e97a972d61055599fab0480dd40a87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4e97a972d61055599fab0480dd40a87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ae4e97a972d61055599fab0480dd40a87">clearStorage</a> (ps_storage_id storageID)</td></tr>
<tr class="memdesc:ae4e97a972d61055599fab0480dd40a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the block for the given handle  the handle to the persistent memory which was obtained by the &lt;getHandle&gt; function  the enum defining the storage struct type, used to get the size of the struct. <br /></td></tr>
<tr class="separator:ae4e97a972d61055599fab0480dd40a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce072bd27cb4924fb282f50280392a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#abce072bd27cb4924fb282f50280392a3">readStorage</a> (pstorage_handle_t handle, <a class="el" href="structps__storage__base__t.html">ps_storage_base_t</a> *item, uint16_t size)</td></tr>
<tr class="memdesc:abce072bd27cb4924fb282f50280392a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the struct stored in persistent memory at the position defined by the handle  the handle to the persistent memory where the struct is stored.  <a href="#abce072bd27cb4924fb282f50280392a3">More...</a><br /></td></tr>
<tr class="separator:abce072bd27cb4924fb282f50280392a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558e1d24209771635f98d5516e0cca0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a558e1d24209771635f98d5516e0cca0a">writeStorage</a> (pstorage_handle_t handle, <a class="el" href="structps__storage__base__t.html">ps_storage_base_t</a> *item, uint16_t size)</td></tr>
<tr class="memdesc:a558e1d24209771635f98d5516e0cca0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the struct to persistent memory at the position defined by the handle  the handle to the persistent memory where the struct should be stored.  <a href="#a558e1d24209771635f98d5516e0cca0a">More...</a><br /></td></tr>
<tr class="separator:a558e1d24209771635f98d5516e0cca0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d49ccc35dbc711b8edec21965b94c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#aa8d49ccc35dbc711b8edec21965b94c8">readItem</a> (pstorage_handle_t handle, pstorage_size_t offset, uint8_t *item, uint16_t size)</td></tr>
<tr class="memdesc:aa8d49ccc35dbc711b8edec21965b94c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single item (variable) from persistent memory at the position defined by the handle and the offset  the handle to the persistent memory where the struct is stored.  <a href="#aa8d49ccc35dbc711b8edec21965b94c8">More...</a><br /></td></tr>
<tr class="separator:aa8d49ccc35dbc711b8edec21965b94c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789e97ddd3dd01d3cbf6681ae6759df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a789e97ddd3dd01d3cbf6681ae6759df6">writeItem</a> (pstorage_handle_t handle, pstorage_size_t offset, uint8_t *item, uint16_t size)</td></tr>
<tr class="memdesc:a789e97ddd3dd01d3cbf6681ae6759df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single item (variable) to persistent memory at the position defined by the handle and the offset  the handle to the persistent memory where the struct is stored.  <a href="#a789e97ddd3dd01d3cbf6681ae6759df6">More...</a><br /></td></tr>
<tr class="separator:a789e97ddd3dd01d3cbf6681ae6759df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e06845f3cb9c2570532b85adf9286a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e06845f3cb9c2570532b85adf9286a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resumeRequests</b> ()</td></tr>
<tr class="separator:a7e06845f3cb9c2570532b85adf9286a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de8b437c185aec5ff88cc3c466ae682"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3de8b437c185aec5ff88cc3c466ae682"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a3de8b437c185aec5ff88cc3c466ae682">handleEvent</a> (uint16_t evt, void *p_data, uint16_t length)</td></tr>
<tr class="memdesc:a3de8b437c185aec5ff88cc3c466ae682"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle events <br /></td></tr>
<tr class="separator:a3de8b437c185aec5ff88cc3c466ae682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e4100a0fa57bb561a6ed22b471a981"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8e4100a0fa57bb561a6ed22b471a981"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onUpdateDone</b> ()</td></tr>
<tr class="separator:ae8e4100a0fa57bb561a6ed22b471a981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a05f07d13f65b0258c57a22c29fd4e3e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classStorage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a05f07d13f65b0258c57a22c29fd4e3e8">getInstance</a> ()</td></tr>
<tr class="memdesc:a05f07d13f65b0258c57a22c29fd4e3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the singleton instance of this class.  <a href="#a05f07d13f65b0258c57a22c29fd4e3e8">More...</a><br /></td></tr>
<tr class="separator:a05f07d13f65b0258c57a22c29fd4e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b186d5d3bf61b920efc5170ebec487"><td class="memItemLeft" align="right" valign="top">static pstorage_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a01b186d5d3bf61b920efc5170ebec487">getOffset</a> (<a class="el" href="structps__storage__base__t.html">ps_storage_base_t</a> *storage, uint8_t *variable)</td></tr>
<tr class="memdesc:a01b186d5d3bf61b920efc5170ebec487"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper functions  <a href="#a01b186d5d3bf61b920efc5170ebec487">More...</a><br /></td></tr>
<tr class="separator:a01b186d5d3bf61b920efc5170ebec487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1976ccbd5ed67c30e5e03590c3d4c567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1976ccbd5ed67c30e5e03590c3d4c567"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a1976ccbd5ed67c30e5e03590c3d4c567">setString</a> (std::string value, char *target)</td></tr>
<tr class="memdesc:a1976ccbd5ed67c30e5e03590c3d4c567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert std::string to char array  the input string  pointer to the output char array. <br /></td></tr>
<tr class="separator:a1976ccbd5ed67c30e5e03590c3d4c567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a2f8f536ab669330cd822180fcef42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20a2f8f536ab669330cd822180fcef42"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setString</b> (const char *value, uint16_t length, char *target)</td></tr>
<tr class="separator:a20a2f8f536ab669330cd822180fcef42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ebc6c51349b7f650a1fe67d82d7644"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a23ebc6c51349b7f650a1fe67d82d7644">getString</a> (char *value, char *target, char *default_value, uint16_t &amp;size)</td></tr>
<tr class="memdesc:a23ebc6c51349b7f650a1fe67d82d7644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to get std::string from char array in the struct  pointer the input char array  the output string  the default string to be used if no valid string found in the char array.  <a href="#a23ebc6c51349b7f650a1fe67d82d7644">More...</a><br /></td></tr>
<tr class="separator:a23ebc6c51349b7f650a1fe67d82d7644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade29d58beb4662a94a3e7f3aa463741a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ade29d58beb4662a94a3e7f3aa463741a">setUint8</a> (uint8_t value, uint32_t &amp;target)</td></tr>
<tr class="memdesc:ade29d58beb4662a94a3e7f3aa463741a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to set a byte in the field of a struct  the byte value to be copied to the struct  pointer the field in the struct where the value should be set.  <a href="#ade29d58beb4662a94a3e7f3aa463741a">More...</a><br /></td></tr>
<tr class="separator:ade29d58beb4662a94a3e7f3aa463741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879145bb43ada1321e7de90a3f733ffe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a879145bb43ada1321e7de90a3f733ffe">getUint8</a> (uint32_t value, uint8_t *target, uint8_t default_value)</td></tr>
<tr class="memdesc:a879145bb43ada1321e7de90a3f733ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to read a byte from the field of a struct  the field of the struct which should be read  pointer to the byte where the value is returned  the default value if the field of the struct is empty.  <a href="#a879145bb43ada1321e7de90a3f733ffe">More...</a><br /></td></tr>
<tr class="separator:a879145bb43ada1321e7de90a3f733ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510746bb2a9cb0689632b84d26e32cdd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a510746bb2a9cb0689632b84d26e32cdd">setUint16</a> (uint16_t value, uint32_t &amp;target)</td></tr>
<tr class="memdesc:a510746bb2a9cb0689632b84d26e32cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to set a short (uint16_t) in the field of a struct  the value to be copied to the struct  pointer to the field in the struct where the value should be set.  <a href="#a510746bb2a9cb0689632b84d26e32cdd">More...</a><br /></td></tr>
<tr class="separator:a510746bb2a9cb0689632b84d26e32cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae453209296a50de54172db9009f77dfd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ae453209296a50de54172db9009f77dfd">getUint16</a> (uint32_t value, uint16_t *target, uint16_t default_value)</td></tr>
<tr class="memdesc:ae453209296a50de54172db9009f77dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to read a short (uint16_t) from the field of a struct  the field of the struct which should be read  pointer the uint16_t variable where the value is returned  the default value if the field of the struct is empty.  <a href="#ae453209296a50de54172db9009f77dfd">More...</a><br /></td></tr>
<tr class="separator:ae453209296a50de54172db9009f77dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac898a6748ba4211d9db2c60f9315336c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ac898a6748ba4211d9db2c60f9315336c">setInt16</a> (int16_t value, int32_t &amp;target)</td></tr>
<tr class="memdesc:ac898a6748ba4211d9db2c60f9315336c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to set a signed short (int16_t) in the field of a struct  the value to be copied to the struct  pointer the field in the struct where the value should be set.  <a href="#ac898a6748ba4211d9db2c60f9315336c">More...</a><br /></td></tr>
<tr class="separator:ac898a6748ba4211d9db2c60f9315336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00add83f46201b7355250c2571f95b04"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a00add83f46201b7355250c2571f95b04">getInt16</a> (int32_t value, int16_t *target, int16_t default_value)</td></tr>
<tr class="memdesc:a00add83f46201b7355250c2571f95b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to read a signed short (int16_t) from the field of a struct  the field of the struct which should be read  pointer to the int16_t variable where the value is returned  the default value if the field of the struct is empty.  <a href="#a00add83f46201b7355250c2571f95b04">More...</a><br /></td></tr>
<tr class="separator:a00add83f46201b7355250c2571f95b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f129a4e617caa782d8158aebcf26941"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a8f129a4e617caa782d8158aebcf26941">setUint32</a> (uint32_t value, uint32_t &amp;target)</td></tr>
<tr class="memdesc:a8f129a4e617caa782d8158aebcf26941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to set an integer (uint32_t) in the field of a struct  the value to be copied to the struct  pointer to the field in the struct where the value should be set.  <a href="#a8f129a4e617caa782d8158aebcf26941">More...</a><br /></td></tr>
<tr class="separator:a8f129a4e617caa782d8158aebcf26941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a098f90906d344167974a4ca7b3440"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a13a098f90906d344167974a4ca7b3440">getUint32</a> (uint32_t value, uint32_t *target, uint32_t default_value)</td></tr>
<tr class="memdesc:a13a098f90906d344167974a4ca7b3440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to read an integer (uint32_t) from the field of a struct  the field of the struct which should be read  pointer the uint32_t varaible where the value is returned  the default value if the field of the struct is empty.  <a href="#a13a098f90906d344167974a4ca7b3440">More...</a><br /></td></tr>
<tr class="separator:a13a098f90906d344167974a4ca7b3440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515d69b86b016a73cd841621301eee68"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a515d69b86b016a73cd841621301eee68">setInt32</a> (int32_t value, int32_t &amp;target)</td></tr>
<tr class="memdesc:a515d69b86b016a73cd841621301eee68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to set an integer (int32_t) in the field of a struct  the value to be copied to the struct  pointer to the field in the struct where the value should be set.  <a href="#a515d69b86b016a73cd841621301eee68">More...</a><br /></td></tr>
<tr class="separator:a515d69b86b016a73cd841621301eee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad967817d4d1532352a1fb40a4eca1a62"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ad967817d4d1532352a1fb40a4eca1a62">getInt32</a> (int32_t value, int32_t *target, int32_t default_value)</td></tr>
<tr class="memdesc:ad967817d4d1532352a1fb40a4eca1a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to read an integer (int32_t) from the field of a struct  the field of the struct which should be read  pointer the int32_t variable where the value is returned  the default value if the field of the struct is empty.  <a href="#ad967817d4d1532352a1fb40a4eca1a62">More...</a><br /></td></tr>
<tr class="separator:ad967817d4d1532352a1fb40a4eca1a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304f50348a9b6e1d078be1eed11e4211"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a304f50348a9b6e1d078be1eed11e4211">setInt8</a> (int8_t value, int32_t &amp;target)</td></tr>
<tr class="memdesc:a304f50348a9b6e1d078be1eed11e4211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to set a signed byte in the field of a struct  the byte value to be copied to the struct  pointer the field in the struct where the value should be set.  <a href="#a304f50348a9b6e1d078be1eed11e4211">More...</a><br /></td></tr>
<tr class="separator:a304f50348a9b6e1d078be1eed11e4211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621332992494371ff8f0ccb5b6474dc6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a621332992494371ff8f0ccb5b6474dc6">getInt8</a> (int32_t value, int8_t *target, int8_t default_value)</td></tr>
<tr class="memdesc:a621332992494371ff8f0ccb5b6474dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to read a signed byte from the field of a struct  the field of the struct which should be read  pointer to the byte where the value is returned  the default value if the field of the struct is empty.  <a href="#a621332992494371ff8f0ccb5b6474dc6">More...</a><br /></td></tr>
<tr class="separator:a621332992494371ff8f0ccb5b6474dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6476c10ae78744d342cab2904080ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a6476c10ae78744d342cab2904080ca"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setFloat</b> (float value, float &amp;target)</td></tr>
<tr class="separator:a6a6476c10ae78744d342cab2904080ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e2d2da3410e4dd8857c6d5cf25dc5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2e2d2da3410e4dd8857c6d5cf25dc5d"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>getFloat</b> (float value, float *target, float default_value)</td></tr>
<tr class="separator:aa2e2d2da3410e4dd8857c6d5cf25dc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d16f6feb126d3e4c471778ff20c9863"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d16f6feb126d3e4c471778ff20c9863"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorage.html#a4d16f6feb126d3e4c471778ff20c9863">setArray</a> (T *src, T *dest, uint16_t length)</td></tr>
<tr class="memdesc:a4d16f6feb126d3e4c471778ff20c9863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to write/copy an array to the field of a struct  primitive type, such as uint8_t  pointer to the array to be written  pointer to the array field of the struct  the number of elements in the source array.  <a href="#a4d16f6feb126d3e4c471778ff20c9863">More...</a><br /></td></tr>
<tr class="separator:a4d16f6feb126d3e4c471778ff20c9863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6302bb0575304b9c89d3a7a46d3364c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6302bb0575304b9c89d3a7a46d3364c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorage.html#af6302bb0575304b9c89d3a7a46d3364c">getArray</a> (T *src, T *dest, T *default_value, uint16_t length)</td></tr>
<tr class="memdesc:af6302bb0575304b9c89d3a7a46d3364c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to read an array from a field of a struct  primitive type, such as uint8_t  pointer to the array field of the struct  pointer to the destination array  pointer to an array containing the default values can be NULL pointer  number of elements in the array (all arrays need to have the same length!)  <a href="#af6302bb0575304b9c89d3a7a46d3364c">More...</a><br /></td></tr>
<tr class="separator:af6302bb0575304b9c89d3a7a46d3364c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to store items persistently in FLASH. </p>
<p>Singleton class, can only exist once.</p>
<p>This class provides functions to initialize, clear, write and read persistent memory (FLASH).</p>
<p>The class also provides static helper functions to read and write values from/to the storage structs of the services. They do not operate on the <a class="el" href="classStorage.html" title="Class to store items persistently in FLASH. ">Storage</a> itself, just work with the provided parameters. As such they can be used without unnecessarily instantiating the storage instance. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af6302bb0575304b9c89d3a7a46d3364c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Storage::getArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to read an array from a field of a struct  primitive type, such as uint8_t  pointer to the array field of the struct  pointer to the destination array  pointer to an array containing the default values can be NULL pointer  number of elements in the array (all arrays need to have the same length!) </p>
<dl class="section return"><dt>Returns</dt><dd>returns true if an array was found in storage, false otherwise</dd></dl>
<p>Checks the memory of the source array field. If it is all FF, that means the memory is unassigned. If an array is provided as default_value, that array will be copied to the destination array, if no default_value array is provided (NULL pointer), nothing happens and the destination array will remain as it was. Otherwise, the data from the source array field will be copied to the destination array </p>

</div>
</div>
<a class="anchor" id="aa5e2d45dbf3457ee4f5acbb268be0771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Storage::getHandle </td>
          <td>(</td>
          <td class="paramtype">ps_storage_id&#160;</td>
          <td class="paramname"><em>storageID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_handle_t &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the handle to the persistent memory for the given storage ID. </p>
<p>the enum defining the storage struct which should be accessed  returns the handle to the persistent memory where the requested struct is stored, subsequent calls to read and write from the storage will take this parameter as input</p>
<p>Get the handle to persistent memory for a given storage ID.</p>
<dl class="section return"><dt>Returns</dt><dd>true if operation successful, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a05f07d13f65b0258c57a22c29fd4e3e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classStorage.html">Storage</a>&amp; Storage::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the singleton instance of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>static instance of <a class="el" href="classStorage.html" title="Class to store items persistently in FLASH. ">Storage</a> class </dd></dl>

</div>
</div>
<a class="anchor" id="a00add83f46201b7355250c2571f95b04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::getInt16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to read a signed short (int16_t) from the field of a struct  the field of the struct which should be read  pointer to the int16_t variable where the value is returned  the default value if the field of the struct is empty. </p>
<p>In order to show that the field of the struct is empty (or unassigned) we use the fact that the last byte of the uint32_t field is set to FF. If a value is stored, that byte will be set to 0 to show that the field is assigned and that a valid value can be read.</p>
<p>If the field is unassigned, the default value will be returned instead </p>

</div>
</div>
<a class="anchor" id="ad967817d4d1532352a1fb40a4eca1a62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::getInt32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to read an integer (int32_t) from the field of a struct  the field of the struct which should be read  pointer the int32_t variable where the value is returned  the default value if the field of the struct is empty. </p>
<p>To show that a valid value was set, only values up to 2^32-2 (INT_MAX -1) can be stored, while the value 2^32-1 (INT_MAX) will be used to show that it is unassigned</p>
<p>If the field is unassigned, the default value will be returned instead </p>

</div>
</div>
<a class="anchor" id="a621332992494371ff8f0ccb5b6474dc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::getInt8 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to read a signed byte from the field of a struct  the field of the struct which should be read  pointer to the byte where the value is returned  the default value if the field of the struct is empty. </p>
<p>In order to show that the field of the struct is empty (or unassigned) we use the fact that the last byte of the uint32_t field is set to FF. If a value is stored, that byte will be set to 0 to show that the field is assigned and that a valid value can be read.</p>
<p>If the field is unassigned, the default value will be returned instead </p>

</div>
</div>
<a class="anchor" id="a01b186d5d3bf61b920efc5170ebec487"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pstorage_size_t Storage::getOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps__storage__base__t.html">ps_storage_base_t</a> *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper functions </p>
<p>Helper function to calculate the offset of a variable inside a storage struct  pointer to the storage struct where the variable is stored. (storage struct is a 1 to 1 representation of the FLASH memory)  pointer to the variable inside the struct </p><dl class="section return"><dt>Returns</dt><dd>returns the offset in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a23ebc6c51349b7f650a1fe67d82d7644"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::getString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to get std::string from char array in the struct  pointer the input char array  the output string  the default string to be used if no valid string found in the char array. </p>
<p>In order to show that the field of the struct is unassigned, we use the fact that the last byte of the char array is set to FF. To show that the char array is empty, we fill it with 0.</p>
<p>If the value read from the char array is empty or unassigned the default value will be returned instead </p>

</div>
</div>
<a class="anchor" id="ae453209296a50de54172db9009f77dfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::getUint16 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to read a short (uint16_t) from the field of a struct  the field of the struct which should be read  pointer the uint16_t variable where the value is returned  the default value if the field of the struct is empty. </p>
<p>In order to show that the field of the struct is empty (or unassigned) we use the fact that the last byte of the uint32_t field is set to FF. If a value is stored, that byte will be set to 0 to show that the field is assigned and that a valid value can be read.</p>
<p>If the field is unassigned, the default value will be returned instead </p>

</div>
</div>
<a class="anchor" id="a13a098f90906d344167974a4ca7b3440"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::getUint32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to read an integer (uint32_t) from the field of a struct  the field of the struct which should be read  pointer the uint32_t varaible where the value is returned  the default value if the field of the struct is empty. </p>
<p>To show that a valid value was set, only values up to 2^32-2 (INT_MAX -1) can be stored, while the value 2^32-1 (INT_MAX) will be used to show that it is unassigned</p>
<p>If the field is unassigned, the default value will be returned instead </p>

</div>
</div>
<a class="anchor" id="a879145bb43ada1321e7de90a3f733ffe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::getUint8 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to read a byte from the field of a struct  the field of the struct which should be read  pointer to the byte where the value is returned  the default value if the field of the struct is empty. </p>
<p>In order to show that the field of the struct is empty (or unassigned) we use the fact that the last byte of the uint32_t field is set to FF. If a value is stored, that byte will be set to 0 to show that the field is assigned and that a valid value can be read.</p>
<p>If the field is unassigned, the default value will be returned instead </p>

</div>
</div>
<a class="anchor" id="aa8d49ccc35dbc711b8edec21965b94c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::readItem </td>
          <td>(</td>
          <td class="paramtype">pstorage_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single item (variable) from persistent memory at the position defined by the handle and the offset  the handle to the persistent memory where the struct is stored. </p>
<p>obtain the handle with &lt;getHandle&gt;  pointer to the structure where the data from the persistent memory should be copied into  size of the item (eg. 4 for integer, 1 for a byte, 8 for a byte array of length 8, etc)  the offset in bytes at which the item should be stored. (the offset is relative to the beginning of the block defined by the handle) </p>

</div>
</div>
<a class="anchor" id="abce072bd27cb4924fb282f50280392a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::readStorage </td>
          <td>(</td>
          <td class="paramtype">pstorage_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps__storage__base__t.html">ps_storage_base_t</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the struct stored in persistent memory at the position defined by the handle  the handle to the persistent memory where the struct is stored. </p>
<p>obtain the handle with &lt;getHandle&gt;  pointer to the structure where the data from the persistent memory should be copied into  size of the structure (usually sizeof(struct)) </p>

</div>
</div>
<a class="anchor" id="a4d16f6feb126d3e4c471778ff20c9863"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::setArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to write/copy an array to the field of a struct  primitive type, such as uint8_t  pointer to the array to be written  pointer to the array field of the struct  the number of elements in the source array. </p>
<p>the destination array needs to have space for at least length elements</p>
<p>Copies the data contained in the src array to the destination array. It is not possible to write an array containing only FF to memory, since that is used to show that the array is uninitialized. </p>

</div>
</div>
<a class="anchor" id="ac898a6748ba4211d9db2c60f9315336c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::setInt16 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to set a signed short (int16_t) in the field of a struct  the value to be copied to the struct  pointer the field in the struct where the value should be set. </p>
<p>To show that a valid value was set, the last 2 bytes of the field are set to 0 </p>

</div>
</div>
<a class="anchor" id="a515d69b86b016a73cd841621301eee68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::setInt32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to set an integer (int32_t) in the field of a struct  the value to be copied to the struct  pointer to the field in the struct where the value should be set. </p>
<p>To show that a valid value was set, only values up to 2^32-2 (INT_MAX -1) can be stored, while the value 2^32-1 (INT_MAX) will be used to show that it is unassigned </p>

</div>
</div>
<a class="anchor" id="a304f50348a9b6e1d078be1eed11e4211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::setInt8 </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to set a signed byte in the field of a struct  the byte value to be copied to the struct  pointer the field in the struct where the value should be set. </p>
<p>To show that a valid value was set, the last 3 bytes of the field are set to 0 </p>

</div>
</div>
<a class="anchor" id="a510746bb2a9cb0689632b84d26e32cdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::setUint16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to set a short (uint16_t) in the field of a struct  the value to be copied to the struct  pointer to the field in the struct where the value should be set. </p>
<p>To show that a valid value was set, the last 2 bytes of the field are set to 0 </p>

</div>
</div>
<a class="anchor" id="a8f129a4e617caa782d8158aebcf26941"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::setUint32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to set an integer (uint32_t) in the field of a struct  the value to be copied to the struct  pointer to the field in the struct where the value should be set. </p>
<p>To show that a valid value was set, only values up to 2^32-2 (INT_MAX -1) can be stored, while the value 2^32-1 (INT_MAX) will be used to show that it is unassigned </p>

</div>
</div>
<a class="anchor" id="ade29d58beb4662a94a3e7f3aa463741a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Storage::setUint8 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to set a byte in the field of a struct  the byte value to be copied to the struct  pointer the field in the struct where the value should be set. </p>
<p>To show that a valid value was set, the last 3 bytes of the field are set to 0 </p>

</div>
</div>
<a class="anchor" id="a789e97ddd3dd01d3cbf6681ae6759df6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::writeItem </td>
          <td>(</td>
          <td class="paramtype">pstorage_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single item (variable) to persistent memory at the position defined by the handle and the offset  the handle to the persistent memory where the struct is stored. </p>
<p>obtain the handle with &lt;getHandle&gt;  pointer to the structure where the data from the persistent memory should be copied into  size of the item (eg. 4 for integer, 1 for a byte, 8 for a byte array of length 8, etc)  the offset in bytes at which the item should be stored. (the offset is relative to the beginning of the block defined by the handle) </p>

</div>
</div>
<a class="anchor" id="a558e1d24209771635f98d5516e0cca0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::writeStorage </td>
          <td>(</td>
          <td class="paramtype">pstorage_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps__storage__base__t.html">ps_storage_base_t</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the struct to persistent memory at the position defined by the handle  the handle to the persistent memory where the struct should be stored. </p>
<p>obtain the hanlde with &lt;getHandle&gt;  pointer to the structure which data should be stored into persitent memory  size of the structure (usually sizeof(struct)) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/drivers/<a class="el" href="cs__Storage_8h_source.html">cs_Storage.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
